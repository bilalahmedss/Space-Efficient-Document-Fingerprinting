/**
 * @file CountingBloomFilter.cpp
 * @brief Implementation of the CountingBloomFilter class.
 * 
 * This file provides the implementation of the CountingBloomFilter class, which enables efficient membership
 * testing and deletion operations for document fingerprinting. It uses multiple hash functions to compute the
 * positions in the filter and allows for the increment and decrement of counters at those positions.
 * 
 * The key difference between a standard Bloom filter and the Counting Bloom Filter is that it supports element
 * removal by decrementing counters. This makes it ideal for applications like detecting duplicate documents
 * and comparing documents for similarity.
 * 
 * Functions:
 * - CountingBloomFilter(int size, int numHashFunctions): Initializes the filter with the given size and number
 *   of hash functions. It also initializes the filter with zeros.
 * - hash1(const std::string& input): Generates a hash value based on the input string, using a simple formula.
 * - hash2(const std::string& input): Generates a different hash value using a separate formula.
 * - applyHashFunction(const std::string& input, int seed): A configurable hash function that uses a seed to generate
 *   distinct hash values for better distribution.
 * - insert(const std::string& fingerprint): Inserts a fingerprint by incrementing the counters at positions
 *   generated by the hash functions.
 * - contains(const std::string& fingerprint): Checks whether the fingerprint is likely present in the filter by
 *   verifying if all the counters at the hash positions are non-zero.
 * - remove(const std::string& fingerprint): Removes a fingerprint by decrementing the counters at the
 *   corresponding hash positions, only if they are greater than zero.
 * - printFilter(): Prints the filter state, showing the current values of the counters for debugging.
 * 
 * @param filter: A vector of counters representing the filter state. Each element holds the count of elements hashed
 *                to that position.
 * @param size: The total number of counters in the filter, determining its capacity.
 * @param numHashFunctions: The number of hash functions used for mapping fingerprints to filter positions.
 */

#include "CountingBloomFilter.h"
#include <iostream>
#include <cmath>
#include <functional>  // For std::hash

CountingBloomFilter::CountingBloomFilter(int size, int hashCount)
    : size(size), hashCount(hashCount) {
    filter.resize(size, 0);  // Initialize the filter with zeros
}

// Simple hash function 1 (for demonstration)
int CountingBloomFilter::hash1(const std::string& input) const {
    int hashValue = 0;
    for (char c : input) {
        hashValue = (hashValue * 31 + c) % size;
    }
    return hashValue;
}

// Simple hash function 2 (for demonstration)
int CountingBloomFilter::hash2(const std::string& input) const {
    int hashValue = 0;
    for (char c : input) {
        hashValue = (hashValue * 37 + c) % size;
    }
    return hashValue;
}

// General-purpose hash function (configurable seed for better distribution)
int CountingBloomFilter::applyHashFunction(const std::string &input, int seed) const {
    std::hash<std::string> hash_fn;
    return hash_fn(input + std::to_string(seed)) % size;
}

// Insert a fingerprint into the filter, incrementing counters at calculated positions
void CountingBloomFilter::insert(const std::string& fingerprint) {
    for (int i = 0; i < hashCount; ++i) {
        int index = applyHashFunction(fingerprint, i);
        filter[index]++;  // Increment the counter at the computed index
    }
}

// Check if a fingerprint is likely in the filter
bool CountingBloomFilter::contains(const std::string& fingerprint) const {
    for (int i = 0; i < hashCount; ++i) {
        int index = applyHashFunction(fingerprint, i);
        if (filter[index] == 0) {
            return false;  // If any counter is zero, the fingerprint isn't present
        }
    }
    return true;  // All hash positions have non-zero values
}

// Remove a fingerprint from the filter, decrementing counters where possible
void CountingBloomFilter::remove(const std::string& fingerprint) {
    for (int i = 0; i < hashCount; ++i) {
        int index = applyHashFunction(fingerprint, i);
        // Decrement counters only if they are greater than zero to avoid underflow
        if (filter[index] > 0) {
            filter[index]--;
        }
    }
}

// Debugging method to display the current state of the filter
void CountingBloomFilter::printFilter() const {
    for (int i = 0; i < size; i++) {
        std::cout << filter[i] << " ";
    }
    std::cout << std::endl;
}
